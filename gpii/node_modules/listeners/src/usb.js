/*
 * USB user listener
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    ffi = require("ffi"),
    ref = require("ref"),
    Struct = require("ref-struct"),
    fs = require("fs"),
    path = require("path");

var windows = fluid.registerNamespace("gpii.windows");

fluid.require("%gpii-windows/gpii/node_modules/WindowsUtilities/WindowsUtilities.js");

var w32 = {};
var t = windows.types;

w32.API_Constants = {
    // https://msdn.microsoft.com/library/aa363480
    WM_DEVICECHANGE: 0x219,

    // https://msdn.microsoft.com/library/aa363205
    DBT_DEVICEARRIVAL: 0x8000,
    DBT_DEVICEREMOVEPENDING: 0x8003,
    DBT_DEVICEREMOVECOMPLETE: 0x8004,
    DBT_DEVTYP_VOLUME: 0x2
};

// https://msdn.microsoft.com/library/ms632680
w32.user32 = ffi.Library("user32", {
    "CreateWindowExW": [
        t.HANDLE, [
            t.DWORD,    // dwExStyle
            "char*",  // lpClassName
            "char*",  // lpWindowName
            t.DWORD,    // dwStyle
            t.INT,      // X
            t.INT,      // Y
            t.INT,      // nWidth
            t.INT,      // nHeight
            t.HANDLE,   // hWndParent
            t.HANDLE,   // hMenu
            t.HANDLE,   // hInstance
            t.PVOID    // lpParam
        ]
    ],
    // https://msdn.microsoft.com/library/ms633586
    "RegisterClassW": [
        t.HANDLE, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms633572
    "DefWindowProcW": [
        t.HANDLE, [
            t.HANDLE,
            t.UINT,
            t.UINT,
            t.PVOID
        ]
    ],
    // https://msdn.microsoft.com/library/ms644943
    "PeekMessageW": [
        t.BOOL, [ t.PVOID, t.HANDLE, t.UINT, t.UINT, t.UINT ]
    ],
    // https://msdn.microsoft.com/library/ms644955
    "TranslateMessage": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms644934
    "DispatchMessageW": [
        t.BOOL, [ t.PVOID ]
    ]
});

// https://msdn.microsoft.com/library/ms633576
w32.WNDCLASSW = new Struct([
    [t.UINT,      "style"],
    ["void*",     "lpfnWndProc"],
    [t.INT,       "cbClsExtra"],
    [t.INT,       "cbWndExtra"],
    [t.HANDLE,    "hInstance"],
    [t.HANDLE,    "hIcon"],
    [t.HANDLE,    "hCursor"],
    [t.HANDLE,    "hbrBackground"],
    [t.PVOID,     "lpszMenuName"],
    ["char*",     "lpszClassName"]
]);

// https://msdn.microsoft.com/library/aa363246
w32.DEV_BROADCAST_HDR = new Struct([
    [t.DWORD, "size"],
    [t.DWORD, "deviceType"],
    [t.DWORD, "reserved"]
]);

// https://msdn.microsoft.com/library/aa363249
w32.DEV_BROADCAST_VOLUME = new Struct([
    [t.DWORD, "size"],
    [t.DWORD, "deviceType"],
    [t.DWORD, "reserved"],
    [t.DWORD, "unitMask"],
    [t.DWORD, "flags"]
]);

/**
 * WindowProc: https://msdn.microsoft.com/library/ms633573
 *
 * @param hwnd
 * @param msg
 * @param wParam
 * @param lParam
 */
windows.windowProc = function (hwnd, msg, wParam, lParam) {
    console.log("WNDPROC", hwnd, msg, wParam, lParam);
    switch (msg) {
    case w32.API_Constants.WM_DEVICECHANGE:

        switch (wParam) {
        case w32.API_Constants.DBT_DEVICEARRIVAL:
        case w32.API_Constants.DBT_DEVICEREMOVECOMPLETE:
            // DBT_DEVICEARRIVAL: https://msdn.microsoft.com/library/aa363205
            // DBT_DEVICEREMOVECOMPLETE: https://msdn.microsoft.com/library/aa363208

            var arrived = wParam === w32.API_Constants.DBT_DEVICEARRIVAL;

            console.log("DEVICE " + (arrived ? "ARRIVED" : "REMOVED"));

            var hdr = new w32.DEV_BROADCAST_HDR(lParam.reinterpret(w32.DEV_BROADCAST_HDR.size));

            if (hdr.deviceType === w32.API_Constants.DBT_DEVTYP_VOLUME) {
                var DBTF_NET = 0x2;
                var volume = new w32.DEV_BROADCAST_VOLUME(lParam.reinterpret(w32.DEV_BROADCAST_VOLUME.size));

                // Only local drives.
                if (!(volume.flags & DBTF_NET)) {
                    var bitmask = volume.unitMask;
                    var a = "a".charCodeAt(0);
                    for (var n = 0; bitmask && n < 26; bitmask >>= 1, n++) {
                        if (bitmask & 1) {
                            var dir = String.fromCharCode(a + n) + ":\\";
                            process.nextTick(windows.usbDeviceChange, dir, arrived);
                        }
                    }
                }
            }

            break;
        default:
            break;
        }

        break;
    default:
        break;
    }

    return w32.user32.DefWindowProcW(hwnd, msg, wParam, lParam);
};

var currentDevice = {
    directory: null,
    token: null
};

/**
 * A device has been added or removed.
 *
 * @param directory
 * @param arrived
 */
windows.usbDeviceChange = function (directory, arrived) {
    if (arrived) {
        if (currentDevice.directory) {
            console.log("Already logged in - ignoring.");
        } else {
            windows.readUSBDevice(directory).then(function (token) {
                currentDevice = {
                    directory: directory,
                    token: token
                };
                console.log("LOGIN", currentDevice);
            }, console.log);
        }
    } else if (currentDevice.directory === directory) {
        console.log("LOGOUT", currentDevice);
        currentDevice = {
            directory: null,
            token: null
        };
    } else {
        console.log("Not logged in via this device - ignoring.");
    }
};

/**
 * Read the token file form the usb device.
 *
 * @param directory
 * @return {*}
 */
windows.readUSBDevice = function (directory) {
    var promise = fluid.promise();
    var tokenFile = path.join(directory, ".gpii-user-token.txt");
    console.log("Token file:", tokenFile);
    fs.readFile(tokenFile, "utf8", function (err, data) {
        if (err) {
            console.log(err);
            promise.reject(err);
        } else {
            var token = data.trim();
            console.log("Token:", token);
            promise.resolve(token);
        }
    });

    return promise;
};

/**
 * Polls for messages - only required if not running under electron.
 */
windows.messagePump = function () {

    var loop = function () {
        // sizeof(MSG) = 48 on 64-bit, 28 on 32-bit.
        var msg = new Buffer(process.arch === "x64" ? 48 : 28);

        // Unable to use GetMessage because it blocks, and can't call via .async because it needs to be in the same
        // thread as the window.
        while (w32.user32.PeekMessageW(msg.ref(), 0, 0, 0, 1)) {
            w32.user32.TranslateMessage(msg.ref());
            w32.user32.DispatchMessageW(msg.ref());
        }

        setTimeout(loop, 2000);
    };
    loop();
};

windows.startUSBListener = function () {

    if (!process.versions.electron) {
        windows.messagePump();
    }

    var cls = new w32.WNDCLASSW();
    cls.ref().fill(0);
    // WindowProc: https://msdn.microsoft.com/library/ms633573
    windows.proc = cls.lpfnWndProc = ffi.Callback(t.HANDLE, [t.HANDLE, t.UINT, t.UINT, t.PVOID], windows.windowProc);
    cls.lpszClassName = windows.stringToWideChar("gpii-usb-listener");

    var c = w32.user32.RegisterClassW(cls.ref());
    console.log("RegisterClass", c);

    var hwnd = w32.user32.CreateWindowExW(0, cls.lpszClassName, cls.lpszClassName, 0, 0, 0, 0, 0,
        //w32.API_Constants.HWND_MESSAGE
        0
        , 0, 0, ref.NULL);
    console.log("CreateWindow:", hwnd);

};
setTimeout(windows.startUSBListener, 100);
